<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <title>ğŸ§ª ×‘×“×™×§×ª ××¢×¨×›×ª ×¦×™×•×“</title>
    <style>
        * { box-sizing: border-box; }
        body { font-family: 'Segoe UI', sans-serif; background: #0f172a; color: white; padding: 20px; margin: 0; }
        .container { max-width: 900px; margin: 0 auto; }
        h1 { text-align: center; color: #38bdf8; }
        
        #status { padding: 15px; margin: 15px 0; border-radius: 8px; font-size: 14px; text-align: center; }
        .status-ok { background: #064e3b; border: 1px solid #10b981; }
        .status-error { background: #450a0a; border: 1px solid #ef4444; }
        .status-loading { background: #422006; border: 1px solid #f59e0b; }
        
        .debug-box { background: #000; padding: 15px; border-radius: 8px; font-family: monospace; font-size: 12px; margin: 15px 0; max-height: 150px; overflow-y: auto; }
        .debug-ok { color: #10b981; }
        .debug-error { color: #ef4444; }
        .debug-info { color: #38bdf8; }
        
        .preview-area { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0; }
        .preview-box { background: #1e293b; padding: 20px; border-radius: 10px; text-align: center; }
        .preview-box h3 { color: #94a3b8; margin-top: 0; font-size: 14px; }
        canvas { border: 2px solid #334155; border-radius: 8px; image-rendering: pixelated; }
        
        .items-section { background: #1e293b; padding: 20px; border-radius: 10px; }
        .items-grid { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-top: 15px; }
        .item-btn { width: 70px; height: 70px; border: 2px solid #334155; background: #0f172a; border-radius: 10px; cursor: pointer; padding: 5px; }
        .item-btn:hover { border-color: #38bdf8; }
        .item-btn.selected { border-color: #fbbf24; background: #422006; }
        .item-btn img { width: 100%; height: 100%; object-fit: contain; image-rendering: pixelated; }
        
        .controls { display: flex; gap: 10px; justify-content: center; margin: 15px 0; flex-wrap: wrap; }
        .controls button, .controls select { padding: 10px 15px; background: #334155; border: none; color: white; border-radius: 5px; cursor: pointer; }
        .controls button:hover { background: #475569; }
    </style>
</head>
<body>

<div class="container">
    <h1>ğŸ§ª ×‘×“×™×§×ª ××¢×¨×›×ª ×¦×™×•×“</h1>
    
    <div id="status" class="status-loading">×˜×•×¢×Ÿ...</div>
    
    <div class="debug-box" id="debug"></div>
    
    <div class="preview-area">
        <div class="preview-box">
            <h3>ğŸ‘¤ ×“××•×ª ×‘×¡×™×¡</h3>
            <canvas id="baseCanvas" width="196" height="288"></canvas>
        </div>
        <div class="preview-box">
            <h3>ğŸ‘• + ×¦×™×•×“</h3>
            <canvas id="combinedCanvas" width="196" height="288"></canvas>
        </div>
    </div>
    
    <div class="controls">
        <button onclick="prevFrame()">â—€ ×”×§×•×“×</button>
        <span id="frameInfo" style="padding: 10px;">×¤×¨×™×™×: 0</span>
        <button onclick="nextFrame()">×”×‘× â–¶</button>
        <select id="poseSelect" onchange="changePose()"></select>
        <button onclick="toggleAnim()">â–¶ ×× ×™××¦×™×”</button>
    </div>
    
    <div class="items-section">
        <h3 style="color: #94a3b8; margin-top: 0;">ğŸ‘• ×—×•×œ×¦×•×ª ×–××™× ×•×ª:</h3>
        <div class="items-grid" id="itemsGrid">×˜×•×¢×Ÿ...</div>
    </div>
</div>

<script>
let baseImages = {};
let itemImages = {};
let availableItems = [];
let selectedItem = null;
let currentPose = 'stand1';
let currentFrame = 0;
let isAnimating = false;
let animInterval = null;

const POSES = ['stand1', 'stand2', 'walk1', 'walk2', 'jump', 'alert', 'prone', 'fly', 'ladder', 'swingO1', 'swingO2', 'stabO1'];

function debug(msg, type = 'info') {
    const el = document.getElementById('debug');
    const cls = type === 'ok' ? 'debug-ok' : type === 'error' ? 'debug-error' : 'debug-info';
    el.innerHTML += `<div class="${cls}">[${new Date().toLocaleTimeString()}] ${msg}</div>`;
    el.scrollTop = el.scrollHeight;
}

function setStatus(msg, type = 'loading') {
    const el = document.getElementById('status');
    el.textContent = msg;
    el.className = `status-${type}`;
}

async function loadImage(url) {
    return new Promise(resolve => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = () => {
            debug(`Failed: ${url}`, 'error');
            resolve(null);
        };
        img.src = url;
    });
}

async function loadData() {
    debug('××ª×—×™×œ ×˜×¢×™× ×”...');
    
    // Test API first
    try {
        const apiRes = await fetch('/api/sprites/base-character');
        const apiData = await apiRes.json();
        debug(`API: base-character exists=${apiData.exists}`, apiData.exists ? 'ok' : 'error');
        
        if (!apiData.exists) {
            setStatus('âŒ ××™×Ÿ ×ª×™×§×™×™×ª base_character ×‘×©×¨×ª!', 'error');
            return;
        }
    } catch (e) {
        debug(`API Error: ${e.message}`, 'error');
        setStatus('âŒ ×©×’×™××ª API', 'error');
        return;
    }
    
    // Load base character
    debug('×˜×•×¢×Ÿ ×“××•×ª ×‘×¡×™×¡...');
    const testImg = await loadImage('/sprites/base_character/stand1/0.png');
    if (!testImg) {
        setStatus('âŒ ×œ× ××¦×œ×™×— ×œ×˜×¢×•×Ÿ ×ª××•× ×•×ª base_character', 'error');
        return;
    }
    debug(`×“××•×ª ×‘×¡×™×¡: ${testImg.width}x${testImg.height}`, 'ok');
    
    // Load all poses
    baseImages = {};
    for (const pose of POSES) {
        baseImages[pose] = {};
        for (let i = 0; i < 5; i++) {
            const img = await loadImage(`/sprites/base_character/${pose}/${i}.png`);
            if (img) {
                baseImages[pose][i] = img;
            } else {
                break;
            }
        }
        const count = Object.keys(baseImages[pose]).length;
        if (count > 0) debug(`${pose}: ${count} frames`, 'ok');
    }
    
    // Update pose selector
    const sel = document.getElementById('poseSelect');
    sel.innerHTML = '';
    POSES.forEach(p => {
        if (baseImages[p] && Object.keys(baseImages[p]).length > 0) {
            sel.add(new Option(p, p));
        }
    });
    
    // Fetch items
    debug('×˜×•×¢×Ÿ ×¤×¨×™×˜×™×...');
    try {
        const res = await fetch('/api/sprites/items/top');
        const data = await res.json();
        availableItems = data.items || [];
        debug(`× ××¦××• ${availableItems.length} ×—×•×œ×¦×•×ª`, 'ok');
        renderItems();
    } catch (e) {
        debug(`×©×’×™××” ×‘×˜×¢×™× ×ª ×¤×¨×™×˜×™×: ${e.message}`, 'error');
    }
    
    const loadedPoses = Object.keys(baseImages).filter(p => Object.keys(baseImages[p]).length > 0).length;
    setStatus(`âœ… × ×˜×¢× ×• ${loadedPoses} ×¤×•×–×•×ª, ${availableItems.length} ×¤×¨×™×˜×™×`, 'ok');
    drawPreview();
}

function renderItems() {
    const grid = document.getElementById('itemsGrid');
    grid.innerHTML = '';
    
    // None option
    const noneBtn = document.createElement('button');
    noneBtn.className = 'item-btn' + (!selectedItem ? ' selected' : '');
    noneBtn.innerHTML = '<span style="font-size:30px;">âŒ</span>';
    noneBtn.title = '×œ×œ× ×—×•×œ×¦×”';
    noneBtn.onclick = () => selectItem(null);
    grid.appendChild(noneBtn);
    
    // Items
    for (const item of availableItems) {
        const btn = document.createElement('button');
        btn.className = 'item-btn' + (selectedItem === item.item_id ? ' selected' : '');
        btn.title = item.item_id;
        btn.innerHTML = item.icon_url 
            ? `<img src="${item.icon_url}" alt="${item.item_id}">`
            : '<span style="font-size:30px;">ğŸ‘•</span>';
        btn.onclick = () => selectItem(item.item_id);
        grid.appendChild(btn);
    }
    
    if (availableItems.length === 0) {
        grid.innerHTML += '<p style="color:#64748b;margin:10px;">××™×Ÿ ×¤×¨×™×˜×™× ×‘×ª×™×§×™×™×” items/top/</p>';
    }
}

async function selectItem(itemId) {
    selectedItem = itemId;
    renderItems();
    
    if (itemId && !itemImages[itemId]) {
        debug(`×˜×•×¢×Ÿ ×¡×¤×¨×™×™×˜×™×: ${itemId}`);
        itemImages[itemId] = {};
        
        for (const pose of POSES) {
            if (!baseImages[pose]) continue;
            itemImages[itemId][pose] = {};
            
            for (let i = 0; i < 5; i++) {
                const img = await loadImage(`/sprites/items/top/${itemId}/sprites/${pose}/${i}.png`);
                if (img) {
                    itemImages[itemId][pose][i] = img;
                } else {
                    break;
                }
            }
        }
        debug(`× ×˜×¢× ×• ×¡×¤×¨×™×™×˜×™×: ${itemId}`, 'ok');
    }
    
    drawPreview();
}

function drawPreview() {
    const size = 16;
    
    // Base canvas
    const baseCanvas = document.getElementById('baseCanvas');
    const bCtx = baseCanvas.getContext('2d');
    bCtx.imageSmoothingEnabled = false;
    
    // Checkerboard
    for (let y = 0; y < baseCanvas.height; y += size) {
        for (let x = 0; x < baseCanvas.width; x += size) {
            bCtx.fillStyle = ((x + y) / size) % 2 === 0 ? '#1a1a2a' : '#2a2a3a';
            bCtx.fillRect(x, y, size, size);
        }
    }
    
    const baseImg = baseImages[currentPose]?.[currentFrame];
    if (baseImg) {
        bCtx.drawImage(baseImg, 0, 0, baseCanvas.width, baseCanvas.height);
    }
    
    // Combined canvas
    const combCanvas = document.getElementById('combinedCanvas');
    const cCtx = combCanvas.getContext('2d');
    cCtx.imageSmoothingEnabled = false;
    
    for (let y = 0; y < combCanvas.height; y += size) {
        for (let x = 0; x < combCanvas.width; x += size) {
            cCtx.fillStyle = ((x + y) / size) % 2 === 0 ? '#1a1a2a' : '#2a2a3a';
            cCtx.fillRect(x, y, size, size);
        }
    }
    
    if (baseImg) {
        cCtx.drawImage(baseImg, 0, 0, combCanvas.width, combCanvas.height);
    }
    
    // Draw item layer
    if (selectedItem && itemImages[selectedItem]?.[currentPose]?.[currentFrame]) {
        cCtx.drawImage(itemImages[selectedItem][currentPose][currentFrame], 0, 0, combCanvas.width, combCanvas.height);
    }
    
    const fc = Object.keys(baseImages[currentPose] || {}).length;
    document.getElementById('frameInfo').textContent = `×¤×¨×™×™×: ${currentFrame + 1}/${fc}`;
}

function nextFrame() {
    const fc = Object.keys(baseImages[currentPose] || {}).length;
    if (fc > 0) currentFrame = (currentFrame + 1) % fc;
    drawPreview();
}

function prevFrame() {
    const fc = Object.keys(baseImages[currentPose] || {}).length;
    if (fc > 0) currentFrame = (currentFrame - 1 + fc) % fc;
    drawPreview();
}

function changePose() {
    currentPose = document.getElementById('poseSelect').value;
    currentFrame = 0;
    drawPreview();
}

function toggleAnim() {
    if (isAnimating) {
        clearInterval(animInterval);
        isAnimating = false;
    } else {
        isAnimating = true;
        animInterval = setInterval(nextFrame, 150);
    }
}

// Auto-load when page opens
window.onload = loadData;
</script>
</body>
</html>
